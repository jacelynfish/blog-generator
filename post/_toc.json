{"_list":["service-worker-in-practice","mapbox-localization","generate-3d-map-with-geojson","jest-enzyme-antd-dva","run-once-plugin"],"posts":{"generate-3d-map-with-geojson":{"title":"Three.js空间地理可视化：3D行政区域图开发","date":"2018-10-14 11:37:59","tags":["data visualization","mapbox"],"categories":["JavaScript"],"abstract":"<p>好久没填坑了呀……从毕设到校招培训，感觉这半年一直横冲直撞没啥沉淀，只要项目来需求撸起袖子就肝【。这个月一直在学可视化开发，Three.js 和 Echarts、D3 都略有接触了，今天就讲讲空间地理可视化的一些经验吧~ 💃🏻💃🏻💃🏻</p>\n<blockquote>\n<p>位置数据的最大好处就在于它与现实世界的联系。 —— N. Yau《数据之美》</p>\n</blockquote>\n<p>在数据可视化的过程中，使用地理坐标系来映射具体位置数据能增强数据背后的环境信息和关联信息，使读者能快速总览某一区域的情况，同时也能聚焦在她/他最关心的某一范围。而在可视化数据大屏的实践里，空间可视化因其宏观、酷炫的效果而常常作为大屏底图，如在 3D 地球或 2D 地图瓦片的基础上，加上热力图、飞线等效果，以更好地展示跨地理区域的数据。本文将会介绍如何通过使用 <a href=\"https://threejs.org/\">Three.js</a> 和 <a href=\"https://github.com/d3/d3-geo\">d3-geo</a> 将 Geojson 这种地理数据……"},"jest-enzyme-antd-dva":{"title":"踩坑：使用 Jest+Enzyme 对 AntD/dva 项目进行单元测试","tags":["unit-test","react"],"categories":["JavaScript"],"date":"2018-01-15 21:57:48","abstract":"<blockquote>\n<p>这篇文章并不是前端单测入门介绍</p>\n</blockquote>\n<h2>这是一篇流水账</h2>\n<p>最近这两个星期的开发任务比较少，又开始一边写用例一边疯狂踩坑。毕竟项目本身直接上 <a href=\"https://github.com/dvajs/dva\">dva</a>，对 react/redux/redux-saga 的封装度比较高，而且用的也是蚂蚁的 <a href=\"https://ant.design/\">AntD</a> 的组件库，有时候需要测试某个组件的时候需要绕过很多 dva 和 AntD 的实现，导致经常一个组件的三四个用例就能写一个上午，甚至为了解决一些魔性的 warning 去学习了 <a href=\"https://redux-saga.js.org/\">redux-saga</a> 的原理以及……翻了 dva 的源码【？？？而且 <a href=\"https://facebook.github.io/jest/\">Jest</a> 和 <a href=\"http://airbnb.io/enzyme/\">Enzyme<……"},"mapbox-localization":{"title":"Mapbox 离线资源本地化实践","date":"2018-10-20 00:25:23","tags":["data visualization","GIS","mapbox"],"categories":["JavaScript"],"abstract":"<p>在空间数据可视化领域里，开源产品 <a href=\"https://www.mapbox.com/mapbox-gl-js/api/#map\">Mapbox GL</a> 无疑是搭建 3D 地理场景的最佳选择了。相比于传统的栅格瓦片资源，Mapbox 支持使用矢量地图切片渲染可交互的、<strong>可按图层配置样式</strong>的动态地图，并且使用 Protocol Buffer 编码的瓦片数据体积比图片资源更小，更一步节省地图消耗的流量。<a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a>（下文简称 OSM）为 Mapbox 在线 API 提供了自然/人文地理数据，它是一个由全球各地的地理爱好者共同参与贡献数据的开源项目，而 Mapbox 也是其最大的贡献者之一。</p>\n<p>想要使用 Mapbox GL，最直白的方法便是在引用了相应的 JS/CSS 文件后，使用官方提供的开发者 <code>accessToken</code> 去获取地图瓦片及其他资源，如<a href=\"https://www.mapb……"},"run-once-plugin":{"title":"run-once-plugin原理解析：绕过webpack配置直接操作plugin的加载和卸载","tags":["webpack","optimization"],"categories":["JavaScript"],"date":"2018-01-10 19:08:31","abstract":"<h2>前言</h2>\n<p>在开发环境下，通常在使用 webpack 在简单的 watch 模式下监听文件内容变化重新编译代码的时候，webpack 将整个项目内匹配到的文件全部重新编译一遍，这就导致所有通过配置文件设置的 loader 和 plugin 需要重新执行来生成新代码。然而当项目本身比较小型时，类似于 HtmlWebpackPlugin 这种只需执行一次便可得出需要的文件，在 watch 下反复执行会大大降低每次编译的速度。然而，webpack 本身并没有可以操作 plugin 的加载和卸载时机的配置项，想要在 webpack 执行过程中手动卸载已执行过一次的插件的话，只能通过另外再写一个插件来实现了。</p>\n"},"service-worker-in-practice":{"title":"博客大改造：Service Worker 实践与总结","date":"2018-11-03 01:09:17","tags":["service worker","pwa","optimization"],"categories":["JavaScript"],"abstract":"<p>回归博客一个多月，给自己最大的感受就是使用 GitHub Page 搭建的博客在国内没有梯子的情况下访问实在太慢了，在移动端的首屏加载有时甚至超过 10 秒钟，严重影响交互体验。刚好最近在学习 Service Worker，便决定以自己的博客作为小白鼠，实践离线访问、后台同步和 Preload &amp; Prefetch 等渐进式单页应用的逆天功能吧~</p>\n"}}}