{"meta":{"title":"踩坑：使用 Jest+Enzyme 对 AntD/dva 项目进行单元测试","tags":["unit-test","react"],"categories":["JavaScript"],"date":"2018-01-15 21:57:48"},"content":"<blockquote>\n<p>这篇文章并不是前端单测入门介绍</p>\n</blockquote>\n<h2>这是一篇流水账</h2>\n<p>最近这两个星期的开发任务比较少，又开始一边写用例一边疯狂踩坑。毕竟项目本身直接上 <a href=\"https://github.com/dvajs/dva\">dva</a>，对 react/redux/redux-saga 的封装度比较高，而且用的也是蚂蚁的 <a href=\"https://ant.design/\">AntD</a> 的组件库，有时候需要测试某个组件的时候需要绕过很多 dva 和 AntD 的实现，导致经常一个组件的三四个用例就能写一个上午，甚至为了解决一些魔性的 warning 去学习了 <a href=\"https://redux-saga.js.org/\">redux-saga</a> 的原理以及……翻了 dva 的源码【？？？而且 <a href=\"https://facebook.github.io/jest/\">Jest</a> 和 <a href=\"http://airbnb.io/enzyme/\">Enzyme</a> 本身也有些 known bug 需要魔改的 work around，所以在搭建整个测试的框架的时候也用上了官方的 <a href=\"https://reactjs.org/docs/test-utils.html\">Test Utilities</a> 库和 <a href=\"https://github.com/tmpvar/jsdom\">jsdom</a>。这里就认真记录一下踩到的坑们吧~</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>坑们</h2>\n<h3>Jest 的 Mock 全局检测文件名</h3>\n<blockquote>\n<p>https://github.com/facebook/jest/issues/2070</p>\n</blockquote>\n<p>当开启 automock（这是默认行为）的时候，jest 是全局检测所有的 mockfile 的名称，因此即使 mockfile 放在不同的路径下面，如果他们的文件名本身（不包括 path 的 basename）相同，如 <code>a/__mocks__/services.js</code> 和 <code>b/__mocks__/services.js</code>，就会使 Jest 抛出错误，目前这个还是只个 warning，看起来是 Jest 本身的 Manual Mocks 系统仍然不完善，官方并没有给出解决方案，因此我们仍然需要手动引入需要 mock 的文件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">//work around</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> services <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../services'</span>;\n\njest.disableAutomock();\njest.mock(<span class=\"hljs-string\">'../services'</span>, () =&gt; <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../_mocks_/services'</span>));\n</code></pre>\n<h3>组件测试时建立最小的 dva 实例</h3>\n<p>在正常开发时，如果一个组件下的 <code>state</code> 和 <code>dispatch</code>是通过 <code>connect()</code> 传入的，dva 已经帮我们完成 router 和 store 的创建，并直接通过 <code>&lt;Provider /&gt;</code> 将 store 传入组件。然而在测试的时候，这样一套的封装流程会使真实需要测试的组件代码在虚拟 DOM 的节点非常深，如果使用 Shallow Rendering，在使用 dva 路由的情况下，可能需要从 <code>wrapper</code> 使用 <code>dive()</code> 进行 3、4 次才能找到需要的组件。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">&lt;!-- 没有使用路由的情况下，需要 dive 两层才能找到真实组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">store</span>=<span class=\"hljs-string\">{{...}}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyButton</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{[Function]}</span>&gt;</span>before click<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyButton</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Component</span>&gt;</span>\n</code></pre>\n<p>于是我们利用 dva 创建 Redux store，在测试时直接渲染组件本身，并将需要的 <code>state</code> 和 <code>dispatch</code> 从 dva 获取后手动传入。(这里的 <code>MyButton</code> 组件是没有被 <code>connect()</code> 包裹的原始组件)</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// work around</span>\n<span class=\"hljs-comment\">// __test__/MyButton.test.js</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> { shallow } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'enzyme'</span>;\n<span class=\"hljs-keyword\">import</span> { MyButton } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../MyButton'</span>;\n<span class=\"hljs-keyword\">import</span> model <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../myButtonModel'</span>;\n\n<span class=\"hljs-keyword\">let</span> wrapper, app;\nbeforeAll(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span>{\n  app = dva()\n  app.model(model);\n  app.router(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {});\n  app.start();\n  wrapper = mount(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyButton</span> <span class=\"hljs-attr\">dispatch</span>=<span class=\"hljs-string\">{app._store.dispatch}</span>\n    <span class=\"hljs-attr\">button</span>=<span class=\"hljs-string\">{app._store.getState().button}</span> /&gt;</span>);\n})\nafterAll(() =&gt; {\n  wrapper.unmount();\n})\n// ... test code ...\n</span></code></pre>\n<p>在 <code>wrapper</code> 上使用 <code>debug()</code> 检视一下组件渲染情况，这样获得的 <code>wrapper</code> 便是 <code>MyButton</code> 组件的 Shallow Wrapper 实例，可以直接在上面进行操作了：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyButton</span> <span class=\"hljs-attr\">dispatch</span>=<span class=\"hljs-string\">{[Function]}</span> <span class=\"hljs-attr\">button</span>=<span class=\"hljs-string\">{{...}}</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{[Function]}</span>&gt;</span>before click<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyButton</span>&gt;</span>\n</code></pre>\n<h3>组件内部有监听路由变化的逻辑</h3>\n<p>由于需要监听路由变化，组件需要依赖 <code>context</code> 中的 <code>router</code> 属性来获取 <code>history</code> 对象。在一个 dva 实例里，这个 <code>router</code> 是由 dva 创建并加载到根元素的 <code>childContext</code> 里的，根据这点我从最小 dva 实例作为起点，开始了几个尝试：</p>\n<ol>\n<li>\n<p>渲染最小 dva 实例，直接使用 react-router 的 <code>createBrowserHistory()</code> 等方法直接创建一个 <code>router</code> 实例并手动加入组件的 <code>childContext</code> 传给 <code>&lt;Link /&gt;</code> 标签使用。结果：报错。<em>如果组件里面使用了 <code>&lt;Link /&gt;</code> 等 react-router 的标签，就必须把组件包裹在一个 <code>&lt;Router /&gt;</code> 标签里。</em></p>\n</li>\n<li>\n<p>依赖 dva 的 router，创建一个完整的 dva 实例并照常进行测试。结果：模拟对 <code>&lt;Link /&gt;</code> 的点击或是直接使用 <code>app._history.pushState(nextState); app._history.goForward()</code> 均无效。<em>猜测是 <code>&lt;BrowserRouter /&gt;</code> 在非浏览器环境下无法正常运行。</em></p>\n</li>\n<li>\n<p>按照 2 创建完整 dva 实例，将 <code>&lt;BrowserRouter /&gt;</code> 换为 <code>&lt;Router /&gt;</code>，并通过 <code>createMemoryRouter()</code> 创建 router 实例。（其实这里直接使用 <code>&lt;MemoryRouter /&gt;</code>也是可以的，但单独声明 <code>history</code> 能够更灵活地在其他 test case 中操纵路由跳转）结果：成功。</p>\n</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// work around</span>\n<span class=\"hljs-comment\">// __test__/MyButton.test.js</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> { shallow, mount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'enzyme'</span>;\n<span class=\"hljs-comment\">// 因为直接传入 &lt;Route /&gt; 中，这里的 MyButton 组件</span>\n<span class=\"hljs-comment\">// 已被 withRouter() 以及 connect() 包裹</span>\n<span class=\"hljs-keyword\">import</span> MyButton <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../MyButton'</span>;\n<span class=\"hljs-keyword\">import</span> model <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../myButtonModel'</span>;\n<span class=\"hljs-keyword\">import</span> { createMemoryHistory, Router, Route, Switch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-router'</span>\n\n<span class=\"hljs-keyword\">let</span> app, wrapper, history;\nbeforeAll(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  history = createMemoryHistory();\n  app = dva();\n  app.model(model);\n  app.router(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    &lt;Router history={history}&gt;\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Switch</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">exact</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">\"/\"</span> <span class=\"hljs-attr\">component</span>=<span class=\"hljs-string\">{MyButton}</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">\"/other_path\"</span> <span class=\"hljs-attr\">render</span>=<span class=\"hljs-string\">{</span>&lt;<span class=\"hljs-attr\">div</span>&gt;</span>Other Path<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>}&gt;\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Switch</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Router</span>&gt;</span>\n  })\n  let App = app.start();\n  wrapper = mount(<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span>);\n})\n// ... test code ...\n\n//myButtonModel.js\nexport default {\n  namespace: 'myButton',\n  state: {}, reducers: {}, effects: {},\n  subscriptions: {\n    setup({ history, dispatch }) {\n      return history.listen(({ pathname }) =&gt; {\n        console.log(pathname)\n      });\n    },\n  },\n}\n</span></code></pre>\n<p>在测试环境下，通过 subscriptions 可以顺利在实例创建期间使用 <code>history.listen()</code> 监听路由变化了。</p>\n<h3>Shallow Rendering 的几个坑</h3>\n<h4>1. Enzyme 的 shallow 渲染的 ref 属性无效</h4>\n<blockquote>\n<p>https://github.com/airbnb/enzyme/issues/316</p>\n</blockquote>\n<p>Enzyme 的文档里，在 Shallow Rendering 的章节并没有提及 <code>ref()</code> 函数，在实践中，假设我有一个这样的组件，组件内部靠使用 <code>ref</code> 给父组件传递元素：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// MyButton.js</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyButton</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(props) {\n        <span class=\"hljs-keyword\">super</span>(props);\n        <span class=\"hljs-keyword\">this</span>.state = { <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'before click'</span> };\n    }\n    render() {\n        <span class=\"hljs-keyword\">return</span> (\n            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">data-text</span>=<span class=\"hljs-string\">{this.state.text}</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{this.props.wrappedRef}</span>\n                    <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> { this.setState({ text: 'after click' }); }}&gt;\n                    {this.state.text}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n        );\n    }\n}\n</code></pre>\n<p>如果用例中使用 <code>shallow()</code> 来渲染</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> saveBtn = jest.fn(<span class=\"hljs-function\"><span class=\"hljs-params\">btn</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (btn) btnNd = btn;\n});\n<span class=\"hljs-keyword\">let</span> wrapper = mount(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyButton</span> <span class=\"hljs-attr\">wrappedRef</span>=<span class=\"hljs-string\">{saveBtn}</span> /&gt;</span>);\n</span></code></pre>\n<p>这时候如果检测 <code>btn</code> 会发现它的值是 <code>undefined</code>。然而使用 <code>mount()</code> 能正确获得这个 <code>ref</code> 引用的元素：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// work around</span>\n<span class=\"hljs-comment\">// __test__/MyButton.test.js</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> { shallow, mount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'enzyme'</span>;\n<span class=\"hljs-keyword\">import</span> MyButton <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../MyButton'</span>;\n\ntest(<span class=\"hljs-string\">'ref test'</span>, () =&gt; {\n    <span class=\"hljs-keyword\">let</span> btnNd;\n    <span class=\"hljs-keyword\">let</span> saveBtn = jest.fn(<span class=\"hljs-function\"><span class=\"hljs-params\">btn</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (btn) btnNd = btn;\n    });\n    <span class=\"hljs-keyword\">let</span> wrapper = mount(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyButton</span> <span class=\"hljs-attr\">wrappedRef</span>=<span class=\"hljs-string\">{saveBtn}</span> /&gt;</span>);\n\n    wrapper.find('button').simulate('click');\n    expect(btnNd.dataset.text).toBe(\"after click\") // pass\n});\n</span></code></pre>\n<p>同时，如果是 <a href=\"https://reactjs.org/docs/uncontrolled-components.html\">Uncontrolled Component</a> 例如有 <code>ref</code> 属性的 <code>&lt;input&gt;</code> 直接在这个 component 上用 <code>simulate</code> 也无法触发模拟事件。如需触发模拟事件，需要将组件渲染至虚拟 DOM 里，并手动编写 DOM 的事件触发代码，如</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// work around</span>\n<span class=\"hljs-keyword\">let</span> input = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'my-input'</span>);\ninput.addEventListener(<span class=\"hljs-string\">'keydown'</span>, (e) =&gt; { e.target.value = e.key });\n<span class=\"hljs-keyword\">let</span> evnt = <span class=\"hljs-keyword\">new</span> KeyboardEvent(<span class=\"hljs-string\">'keydown'</span>, { <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'1'</span>});\ninput.dispatchEvent(evnt);\n<span class=\"hljs-built_in\">console</span>.log(input.value); <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<h4>2. Redux 状态更新后视图层不自动更新</h4>\n<blockquote>\n<p>https://github.com/airbnb/enzyme/issues/465</p>\n</blockquote>\n<p>如果通过建立最小 dva 实例的方法来创建一个组件的 wrapper，将 Redux 的 state 当做 <code>props</code> 传入一个组件，且通过视图层的交互（如点击一个按钮，在 <code>onClick</code> 的事件处理里更新 state）来更新 Redux store 的状态，在 state 改变之后视图层不会主动重新渲染。之前以为是更新 state 存在异步行为，但是在测试过 <code>setTimeout()</code>, <code>setImmediate()</code> 和 <code>process.nextTick()</code>等方案均无果后，我们发现 <strong>由于 <code>shallow()</code> 不会主动调用 <code>componentWillReceiveProps()</code> 等更新的钩子函数，要更新视图层，需要调用 Enzyme 的 <code>setProps()</code> 函数来触发钩子函数的调用。</strong> 之前不太熟悉 dva 的 API，在每个 test case 前面都加了更新的代码，其实只需在创建 dva 实例时给 <code>onStateChange</code> 钩子加上 handler 就好了~</p>\n<pre class=\"hljs\"><code>app = dva({\n  <span class=\"hljs-attr\">onStateChange</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    wrapper &amp;&amp;\n    wrapper.setProps({app._store.getState().button})\n  }\n})\n</code></pre>\n<p>然而这样只能保证在每个 test case 开始之前组件的视图层都处于最新状态；如果在 test case 里面更新了 Redux 的 state 后需要 assert，那还是要手动调用一次 <code>setProps()</code>。【(/&quot;≡ _ ≡)/~┴┴ 我也觉得这样的写法太脏了，如果小天使们发现有更好的解决方法欢迎在评论里分享呀~】</p>\n<h3>自定义的事件的触发</h3>\n<p>AntD 的某些组件，例如 Modal 在浅渲染时，组件自带的 Button 会被生成在渲染树很深的节点，无法简便地通过触发目标元素的 <code>onClick</code> 事件来触发 Modal 的 <code>onOk</code>、<code>onCancel</code> 等事件；在使用 Mount Rendering 时，<code>simulate()</code> 无法模拟自定义的事件，例如 AntD Input.Search 上的 <code>onSearch</code> 事件，会抛出以下错误：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-built_in\">TypeError</span>: ReactWrapper::simulate() event <span class=\"hljs-string\">'search'</span> does not exist\n</code></pre>\n<p>这类无法直接在组件本身触发事件的情况其实不一定要用 <code>simulate</code> 来解决，这些 <code>onSearch</code>, <code>onOk</code> 事件本身也是赋值在组件上的属性，它们的值是普通的回调函数，因此可以直接通过 <code>prop()</code> 来获取并调用。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// work around</span>\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> { mount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'enzyme'</span>;\n<span class=\"hljs-keyword\">import</span> { Input } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'antd'</span>;\n\n<span class=\"hljs-keyword\">let</span> wrapper;\n<span class=\"hljs-keyword\">let</span> searchText = <span class=\"hljs-string\">'search text'</span>;\n<span class=\"hljs-keyword\">let</span> Search = Input.Search;\n<span class=\"hljs-keyword\">let</span> mockSearch = jest.fn(<span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(text);\n});\n\nbeforeAll(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    wrapper = mount(\n        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Search</span> <span class=\"hljs-attr\">onSearch</span>=<span class=\"hljs-string\">{mockSearch}</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    );\n});\nafterAll(() =&gt; {\n    wrapper.unmount();\n});\ntest.only('event test', () =&gt; {\n    wrapper.find('Search').prop('onSearch')(searchText);\n    expect(mockSearch).toBeCalledWith(searchText);\n});\n</span></code></pre>\n<h2>吐槽</h2>\n<p>接触 React 已经两个月了。这两个月里接触了 redux, react-router, redux-saga，以及在项目上大量使用 dva 和 AntD。然而上面的经验都是从实践中得来的，还没来得及去翻看全家桶的源码，从底层明白这些坑是怎么产生的，以至于有时候走了很多弯路。如果今后测试过程中发现了其他值得提及的点，也会来更新哒！(｀ ∀´)Ψ</p>\n"}